"use strict";

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.PivotTableEngine = void 0;

var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));

var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));

var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));

var _objectSpread2 = _interopRequireDefault(require("@babel/runtime/helpers/objectSpread"));

var _times = _interopRequireDefault(require("lodash/times"));

var dataFields = ['value', 'numerator', 'denominator', 'factor', 'multiplier', 'divisor'];
var CELL_TYPE_VALUE = 'value';
var CELL_TYPE_SUBTOTAL = 'subtotal';
var CELL_TYPE_TOTAL = 'total';
var defaultOptions = {
  hideEmptyColumns: false,
  hideEmptyRows: false,
  showRowTotals: false,
  showColumnTotals: false,
  showRowSubtotals: false,
  showColumnSubtotals: false,
  aggregateType: 'count'
};

var countFromDisaggregates = function countFromDisaggregates(list) {
  if (list.length === 0) {
    return 0;
  }

  var count = 1;
  list.forEach(function (x) {
    count *= x.items.length;
  });
  return count;
};

var addSize = function addSize(list) {
  var reversedList = list.slice().reverse();
  reversedList.forEach(function (level, idx) {
    // Start at the "leaf" disaggregate
    var lastLevel = reversedList[idx - 1];
    level.size = lastLevel ? lastLevel.count * lastLevel.size : 1;
  });
};

var listByDimension = function listByDimension(list) {
  return list.reduce(function (all, item) {
    all[item.dimension] = item;
    return all;
  }, {});
};

var buildDimensionLookup = function buildDimensionLookup(visualization, metadata, headers) {
  var rows = visualization.rows.map(function (row) {
    return {
      dimension: row.dimension,
      count: metadata.dimensions[row.dimension].length,
      itemIds: metadata.dimensions[row.dimension],
      items: metadata.dimensions[row.dimension].map(function (item) {
        return metadata.items[item];
      }),
      position: 'row'
    };
  });
  var columns = visualization.columns.map(function (column) {
    return {
      dimension: column.dimension,
      count: metadata.dimensions[column.dimension].length,
      itemIds: metadata.dimensions[column.dimension],
      items: metadata.dimensions[column.dimension].map(function (item) {
        return metadata.items[item];
      }),
      position: 'column'
    };
  });
  addSize(rows);
  addSize(columns);
  var allByDimension = (0, _objectSpread2.default)({}, listByDimension(rows), listByDimension(columns));
  var headerDimensions = headers.map(function (header) {
    return allByDimension[header.name];
  });
  var rowHeaders = headerDimensions.map(function (_, idx) {
    return idx;
  }).filter(function (idx) {
    return headerDimensions[idx] && headerDimensions[idx].position === 'row';
  });
  var columnHeaders = headerDimensions.map(function (_, idx) {
    return idx;
  }).filter(function (idx) {
    return headerDimensions[idx] && headerDimensions[idx].position === 'column';
  });
  var dataHeaders = dataFields.reduce(function (out, field) {
    out[field] = headers.findIndex(function (header) {
      return header.name === field;
    });
    return out;
  }, {});
  return {
    rows: rows,
    columns: columns,
    allByDimension: allByDimension,
    headerDimensions: headerDimensions,
    rowHeaders: rowHeaders,
    columnHeaders: columnHeaders,
    dataHeaders: dataHeaders
  };
};

var lookup = function lookup(dataRow, dimensionLookup, _ref) {
  var doColumnSubtotals = _ref.doColumnSubtotals,
      doRowSubtotals = _ref.doRowSubtotals;
  var row = 0;
  dimensionLookup.rowHeaders.forEach(function (headerIndex) {
    var idx = dimensionLookup.headerDimensions[headerIndex].itemIds.indexOf(dataRow[headerIndex]);
    var size = dimensionLookup.headerDimensions[headerIndex].size;
    row += idx * size;
  });

  if (doColumnSubtotals) {
    row += Math.floor(row / dimensionLookup.rows[0].size);
  }

  var column = 0;
  dimensionLookup.columnHeaders.forEach(function (headerIndex) {
    var idx = dimensionLookup.headerDimensions[headerIndex].itemIds.indexOf(dataRow[headerIndex]);
    var size = dimensionLookup.headerDimensions[headerIndex].size;
    column += idx * size;
  });

  if (doRowSubtotals) {
    column += Math.floor(column / dimensionLookup.columns[0].size);
  }

  return {
    column: column,
    row: row
  };
};

var PivotTableEngine =
/*#__PURE__*/
function () {
  function PivotTableEngine(visualization, data) {
    (0, _classCallCheck2.default)(this, PivotTableEngine);
    (0, _defineProperty2.default)(this, "visualization", void 0);
    (0, _defineProperty2.default)(this, "rawData", void 0);
    (0, _defineProperty2.default)(this, "options", void 0);
    (0, _defineProperty2.default)(this, "dimensionLookup", void 0);
    (0, _defineProperty2.default)(this, "columnDepth", 0);
    (0, _defineProperty2.default)(this, "rowDepth", 0);
    (0, _defineProperty2.default)(this, "height", 0);
    (0, _defineProperty2.default)(this, "width", 0);
    (0, _defineProperty2.default)(this, "data", []);
    (0, _defineProperty2.default)(this, "occupiedColumns", []);
    (0, _defineProperty2.default)(this, "rowMap", []);
    (0, _defineProperty2.default)(this, "columnMap", []);
    this.visualization = visualization;
    this.rawData = data;
    this.options = (0, _objectSpread2.default)({}, defaultOptions, {
      showColumnTotals: visualization.colTotals,
      showRowTotals: visualization.rowTotals,
      showColumnSubtotals: visualization.colSubTotals,
      showRowSubtotals: visualization.rowSubTotals,
      hideEmptyColumns: visualization.hideEmptyColumns,
      hideEmptyRows: visualization.hideEmptyRows
    });
    this.dimensionLookup = buildDimensionLookup(this.visualization, this.rawData.metaData, this.rawData.headers);
    this.columnDepth = this.dimensionLookup.columns.length;
    this.rowDepth = this.dimensionLookup.rows.length;
    this.buildMatrix();
  }

  (0, _createClass2.default)(PivotTableEngine, [{
    key: "get",
    value: function get(_ref2) {
      var row = _ref2.row,
          column = _ref2.column;
      var type = this.getCellType({
        row: row,
        column: column
      });
      var mappedRow = this.rowMap[row],
          mappedColumn = this.columnMap[column];

      if (!mappedRow && mappedRow !== 0 || !mappedColumn && mappedColumn !== 0) {
        return undefined;
      }

      if (this.data[mappedRow]) {
        var dataRow = this.data[mappedRow][mappedColumn];

        if (dataRow) {
          switch (type) {
            case CELL_TYPE_VALUE:
              return dataRow[this.dimensionLookup.dataHeaders.value] ? dataRow[this.dimensionLookup.dataHeaders.value] : undefined;

            default:
              //TODO: Different aggregation types (count only works for now)
              return dataRow.count ? dataRow.count : undefined;
          }
        }
      }

      return undefined;
    }
  }, {
    key: "rowIsEmpty",
    value: function rowIsEmpty(row) {
      return !this.data[row] || this.data[row].length === 0;
    }
  }, {
    key: "columnIsEmpty",
    value: function columnIsEmpty(column) {
      return !this.occupiedColumns[column];
    }
  }, {
    key: "getColumnHeader",
    value: function getColumnHeader(column) {
      column = this.columnMap[column];

      if (this.options.showRowTotals && column === this.dataWidth - 1) {
        return (0, _times.default)(this.dimensionLookup.columns.length - 1, function () {
          return undefined;
        }).concat([{
          name: 'TOTAL'
        }]);
      }

      if (this.doRowSubtotals) {
        if ((column + 1) % (this.dimensionLookup.columns[0].size + 1) === 0) {
          return [];
        }

        column -= Math.floor(column / (this.dimensionLookup.columns[0].size + 1));
      }

      return this.dimensionLookup.columns.map(function (dimension) {
        var itemIndex = Math.floor(column / dimension.size) % dimension.count;
        return dimension.items[itemIndex];
      });
    }
  }, {
    key: "getRowHeader",
    value: function getRowHeader(row) {
      row = this.rowMap[row];

      if (this.options.showColumnTotals && row === this.dataHeight - 1) {
        return (0, _times.default)(this.dimensionLookup.rows.length - 1, function () {
          return undefined;
        }).concat([{
          name: 'TOTAL'
        }]);
      }

      if (this.doColumnSubtotals) {
        if ((row + 1) % (this.dimensionLookup.rows[0].size + 1) === 0) {
          return [];
        }

        row -= Math.floor(row / (this.dimensionLookup.rows[0].size + 1));
      }

      return this.dimensionLookup.rows.map(function (dimension) {
        var itemIndex = Math.floor(row / dimension.size) % dimension.count;
        return dimension.items[itemIndex];
      });
    }
  }, {
    key: "getDependantTotalCells",
    value: function getDependantTotalCells(_ref3) {
      var row = _ref3.row,
          column = _ref3.column;
      var rowSubtotalSize = this.dimensionLookup.columns[0].size + 1;
      var rowSubtotal = this.doRowSubtotals && {
        row: row,
        column: Math.ceil((column + 1) / rowSubtotalSize) * rowSubtotalSize - 1,
        size: rowSubtotalSize - 1
      };
      var columnSubtotalSize = this.dimensionLookup.rows[0].size + 1;
      var columnSubtotal = this.options.showColumnSubtotals && {
        row: Math.ceil((row + 1) / columnSubtotalSize) * columnSubtotalSize - 1,
        column: column,
        size: columnSubtotalSize - 1
      };
      var rowTotal = this.options.showRowTotals && {
        row: row,
        column: this.dataWidth - 1,
        size: this.rawDataWidth
      };
      var columnTotal = this.options.showColumnTotals && {
        row: this.dataHeight - 1,
        column: column,
        size: this.rawDataHeight
      };
      return {
        rowSubtotal: rowSubtotal,
        columnSubtotal: columnSubtotal,
        rowTotal: rowTotal,
        columnTotal: columnTotal
      };
    }
  }, {
    key: "addCellValueToTotals",
    value: function addCellValueToTotals(pos, dataRow) {
      var _this = this;

      var totals = this.getDependantTotalCells(pos);
      Object.values(totals).forEach(function (totalItem) {
        if (!totalItem) return;
        _this.data[totalItem.row] = _this.data[totalItem.row] || [];
        _this.occupiedColumns[totalItem.column] = true;
        _this.data[totalItem.row][totalItem.column] = _this.data[totalItem.row][totalItem.column] || {
          count: 0,
          totalCount: totalItem.size
        };
        var totalCell = _this.data[totalItem.row][totalItem.column];
        dataFields.forEach(function (field) {
          var headerIndex = _this.dimensionLookup.dataHeaders[field]; // TODO: Fix number parsing, check data type in header

          var value = Number(dataRow[headerIndex]);

          if (value && !isNaN(value)) {
            totalCell[field] += value;
          }
        });
        totalCell.count += 1;
      });
    }
  }, {
    key: "finalizeTotals",
    value: function finalizeTotals() {// TODO: Calculate averages (and other agg types), compute "intersection" totals/subtotals
    }
  }, {
    key: "getCellType",
    value: function getCellType(_ref4) {
      var row = _ref4.row,
          column = _ref4.column;
      row = this.rowMap[row];
      column = this.columnMap[column];
      var isRowTotal = this.options.showRowTotals && column === this.dataWidth - 1;
      var isColumnTotal = this.options.showColumnTotals && row === this.dataHeight - 1;

      if (isRowTotal || isColumnTotal) {
        return CELL_TYPE_TOTAL;
      }

      var isRowSubtotal = this.doRowSubtotals && (column + 1) % (this.dimensionLookup.columns[0].size + 1) === 0;
      var isColumnSubtotal = this.doColumnSubtotals && (row + 1) % (this.dimensionLookup.rows[0].size + 1) === 0;

      if (isRowSubtotal || isColumnSubtotal) {
        return CELL_TYPE_SUBTOTAL;
      }

      return CELL_TYPE_VALUE;
    }
  }, {
    key: "buildMatrix",
    value: function buildMatrix() {
      var _this2 = this;

      this.data = [];
      this.occupiedColumns = [];
      this.dataHeight = this.rawDataHeight = countFromDisaggregates(this.dimensionLookup.rows);
      this.dataWidth = this.rawDataWidth = countFromDisaggregates(this.dimensionLookup.columns); // TODO: Check last row/col dimension for size===1, skip redundant sub-totals

      this.doRowSubtotals = this.options.showRowSubtotals && this.dimensionLookup.columns.length > 1;
      this.doColumnSubtotals = this.options.showColumnSubtotals && this.dimensionLookup.rows.length > 1;

      if (this.doRowSubtotals) {
        this.dataWidth += this.dimensionLookup.columns[0].count;
      }

      if (this.doColumnSubtotals) {
        this.dataHeight += this.dimensionLookup.rows[0].count;
      }

      if (this.options.showRowTotals) {
        this.dataWidth += 1;
      }

      if (this.options.showColumnTotals) {
        ;
        "";
        this.dataHeight += 1;
      }

      this.rawData.rows.forEach(function (dataRow) {
        var pos = lookup(dataRow, _this2.dimensionLookup, _this2);
        _this2.data[pos.row] = _this2.data[pos.row] || [];
        _this2.data[pos.row][pos.column] = dataRow;
        _this2.occupiedColumns[pos.column] = true;

        _this2.addCellValueToTotals(pos, dataRow);
      });
      this.finalizeTotals();
      this.columnMap = this.options.hideEmptyColumns ? (0, _times.default)(this.dataWidth, function (n) {
        return n;
      }).filter(function (idx) {
        return !!_this2.occupiedColumns[idx];
      }) : (0, _times.default)(this.dataWidth, function (n) {
        return n;
      });
      this.rowMap = this.options.hideEmptyRows ? (0, _times.default)(this.dataHeight, function (n) {
        return n;
      }).filter(function (idx) {
        return !!_this2.data[idx];
      }) : (0, _times.default)(this.dataHeight, function (n) {
        return n;
      });
      this.height = this.rowMap.length;
      this.width = this.columnMap.length;
    }
  }]);
  return PivotTableEngine;
}();

exports.PivotTableEngine = PivotTableEngine;